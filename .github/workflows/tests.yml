name: Lakos OS Build and Test

on:
  push:
    branches: [ main, master, develop ]
  pull_request:
    branches: [ main, master, develop ]
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y nasm gcc-multilib g++-multilib make xorriso 

      - name: Build kernel
        run: |
          make clean || true
          make lakos.bin

      - name: Build modules.tar
        run: make modules.tar

      - name: Build ISO image
        run: make iso

      - name: Upload ISO artifact
        uses: actions/upload-artifact@v4
        with:
          name: lakos-iso
          path: lakos.iso
          retention-days: 7

  code-quality:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc-multilib cppcheck

      - name: Check code style
        run: |
          echo "Checking C files for basic issues..."
          find kernel -name "*.c" -exec echo "Checking: {}" \;
          
      - name: Static analysis with cppcheck
        run: |
          cppcheck --version
          cppcheck --enable=warning,performance --std=c99 \
            --suppress=missingIncludeSystem \
            --error-exitcode=0 \
            kernel/ || true

  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc gcc-multilib make

      - name: Create test directory
        run: mkdir -p tests

      - name: Create test runner
        run: |
          cat > tests/test_lib.c << 'EOF'
          #include <stdio.h>
          #include <string.h>
          #include <stdlib.h>
          
          void strcpy_custom(char* dest, const char* src) {
              while (*src) *dest++ = *src++;
              *dest = '\0';
          }
          
          int strcmp_custom(const char* s1, const char* s2) {
              while (*s1 && (*s1 == *s2)) { s1++; s2++; }
              return *(const unsigned char*)s1 - *(const unsigned char*)s2;
          }
          
          int strlen_custom(const char* s) {
              int len = 0;
              while (*s++) len++;
              return len;
          }
          
          int atoi_custom(const char* s) {
              int n = 0;
              while (*s >= '0' && *s <= '9') {
                  n = n * 10 + (*s - '0');
                  s++;
              }
              return n;
          }
          
          void* memcpy_custom(void* dest, const void* src, unsigned int n) {
              char* d = (char*)dest;
              const char* s = (const char*)src;
              while (n--) *d++ = *s++;
              return dest;
          }
          
          void* memset_custom(void* s, int c, unsigned int n) {
              unsigned char* p = (unsigned char*)s;
              while (n--) *p++ = (unsigned char)c;
              return s;
          }
          
          char* strstr_custom(const char* haystack, const char* needle) {
              if (!*needle) return (char*)haystack;
              for (; *haystack; haystack++) {
                  const char* h = haystack;
                  const char* n = needle;
                  while (*h && *n && *h == *n) { h++; n++; }
                  if (!*n) return (char*)haystack;
              }
              return 0;
          }
          
          void itoa_custom(int n, char* buf) {
              if (n == 0) { buf[0] = '0'; buf[1] = '\0'; return; }
              int i = 0, sign = n < 0 ? -1 : 1;
              unsigned int num = n < 0 ? -n : n;
              while (num > 0) { buf[i++] = '0' + num % 10; num /= 10; }
              if (sign < 0) buf[i++] = '-';
              buf[i] = '\0';
              for (int j = 0; j < i/2; j++) { char t = buf[j]; buf[j] = buf[i-1-j]; buf[i-1-j] = t; }
          }
          
          int tests_passed = 0, tests_failed = 0;
          #define TEST(name, cond) do { if (cond) { printf("✓ PASS: %s\n", name); tests_passed++; } else { printf("✗ FAIL: %s\n", name); tests_failed++; } } while(0)
          
          int main() {
              printf("=== Lakos OS Unit Tests ===\n\n");
              printf("--- strlen tests ---\n");
              TEST("strlen empty", strlen_custom("") == 0);
              TEST("strlen 'hello'", strlen_custom("hello") == 5);
              printf("\n--- strcmp tests ---\n");
              TEST("strcmp equal", strcmp_custom("hello", "hello") == 0);
              TEST("strcmp different", strcmp_custom("abc", "abd") < 0);
              printf("\n--- strcpy tests ---\n");
              char buf[100];
              strcpy_custom(buf, "test");
              TEST("strcpy basic", strcmp_custom(buf, "test") == 0);
              printf("\n--- atoi tests ---\n");
              TEST("atoi '123'", atoi_custom("123") == 123);
              TEST("atoi '0'", atoi_custom("0") == 0);
              printf("\n--- memcpy tests ---\n");
              char src[] = "hello", dst[10];
              memcpy_custom(dst, src, 6);
              TEST("memcpy basic", strcmp_custom(dst, "hello") == 0);
              printf("\n--- memset tests ---\n");
              char mem[10];
              memset_custom(mem, 'A', 5);
              mem[5] = '\0';
              TEST("memset basic", strcmp_custom(mem, "AAAAA") == 0);
              printf("\n--- strstr tests ---\n");
              TEST("strstr found", strstr_custom("hello world", "world") != 0);
              TEST("strstr not found", strstr_custom("hello world", "xyz") == 0);
              printf("\n--- itoa tests ---\n");
              char numbuf[20];
              itoa_custom(123, numbuf);
              TEST("itoa 123", strcmp_custom(numbuf, "123") == 0);
              itoa_custom(-42, numbuf);
              TEST("itoa -42", strcmp_custom(numbuf, "-42") == 0);
              printf("\n=== Results: %d passed, %d failed ===\n", tests_passed, tests_failed);
              return tests_failed > 0 ? 1 : 0;
          }
          EOF

      - name: Compile and run unit tests
        run: |
          gcc -o tests/test_lib tests/test_lib.c
          ./tests/test_lib

  crypt-tests:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc

      - name: Create encryption tests
        run: |
          mkdir -p tests
          cat > tests/test_crypt.c << 'EOF'
          #include <stdio.h>
          #include <string.h>
          
          #define MAX_PASS_LEN 64
          
          void encrypt_password(const char* pass, const char* key, char* output) {
              int pass_len = 0, key_len = 0;
              while (pass[pass_len] && pass_len < MAX_PASS_LEN - 1) pass_len++;
              while (key[key_len]) key_len++;
              for (int i = 0; i < pass_len; i++) output[i] = pass[i] ^ key[i % key_len];
              output[pass_len] = '\0';
          }
          
          void decrypt_password(const char* enc, const char* key, char* output) { encrypt_password(enc, key, output); }
          
          int tests_passed = 0, tests_failed = 0;
          #define TEST(name, cond) do { if (cond) { printf("✓ PASS: %s\n", name); tests_passed++; } else { printf("✗ FAIL: %s\n", name); tests_failed++; } } while(0)
          
          int main() {
              printf("=== Encryption Tests ===\n\n");
              char encrypted[100], decrypted[100];
              encrypt_password("password", "key", encrypted);
              decrypt_password(encrypted, "key", decrypted);
              TEST("encrypt/decrypt 'password'", strcmp(decrypted, "password") == 0);
              encrypt_password("root", "secret", encrypted);
              decrypt_password(encrypted, "secret", decrypted);
              TEST("encrypt/decrypt 'root'", strcmp(decrypted, "root") == 0);
              encrypt_password("secret", "key1", encrypted);
              decrypt_password(encrypted, "key2", decrypted);
              TEST("wrong key fails", strcmp(decrypted, "secret") != 0);
              printf("\n=== Results: %d passed, %d failed ===\n", tests_passed, tests_failed);
              return tests_failed > 0 ? 1 : 0;
          }
          EOF

      - name: Compile and run encryption tests
        run: |
          gcc -o tests/test_crypt tests/test_crypt.c
          ./tests/test_crypt

  release:
    needs: [build, code-quality, unit-tests, crypt-tests]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download ISO artifact
        uses: actions/download-artifact@v4
        with:
          name: lakos-iso
          path: .

      - name: Generate version
        id: version
        run: |
          TODAY=$(date +'%Y.%m.%d')
          
          # Get all version tags and find the latest
          LATEST_TAG=$(git tag -l "v[0-9]*.[0-9]*.[0-9]*.[0-9]*" 2>/dev/null | sort -V | tail -1)
          
          if [ -n "$LATEST_TAG" ]; then
            # Extract version parts from tag (vYYYY.MM.DD.patch)
            TAG_VERSION=${LATEST_TAG#v}
            TAG_DATE=$(echo "$TAG_VERSION" | cut -d'.' -f1-3)
            TAG_PATCH=$(echo "$TAG_VERSION" | cut -d'.' -f4)
            
            if [ "$TAG_DATE" = "$TODAY" ]; then
              # Same date, increment patch
              NEW_PATCH=$((TAG_PATCH + 1))
              NEW_VERSION="${TODAY}.${NEW_PATCH}"
            else
              # Different date, use today with patch 1
              NEW_VERSION="${TODAY}.1"
            fi
          else
            # No tags yet, start with today.1
            NEW_VERSION="${TODAY}.1"
          fi
          
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "date=$(date +'%Y-%m-%d')" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION"

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.version.outputs.version }}
          name: Lakos OS ${{ steps.version.outputs.version }}
          body: |
            ## Lakos OS Release ${{ steps.version.outputs.version }}
            
            ### Build Information
            - Date: ${{ steps.version.outputs.date }}
            - Commit: ${{ github.sha }}
            
            ### How to Run
            1. Download `lakos.iso`
            2. Run with QEMU: `qemu-system-i386 -cdrom lakos.iso -m 512M`
            3. Or burn to USB/DVD for real hardware
          files: lakos.iso
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}